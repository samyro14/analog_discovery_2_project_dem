
ğŸ¯ Obiectiv general:
SÄƒ controlaÈ›i Analog Discovery 2 dintr-o aplicaÈ›ie Python (cu interfaÈ›Äƒ graficÄƒ) care:

iniÈ›ializeazÄƒ dispozitivul

preia un semnal analogic de pe un canal

afiÈ™eazÄƒ datele Ã®n timp real sau Ã®ntr-un grafic

ğŸ”§ Tool-uri necesare (toÈ›i)
Tool / BibliotecÄƒ	Rol	Instalare
WaveForms	Driver + aplicaÈ›ie de configurare	Digilent.com
WaveForms SDK	InterfaÈ›Äƒ programaticÄƒ cu dispozitivul	Instalare vine cu WaveForms
Python 3.12	Limbajul de programare	python.org
dwfconstants.py	Wrapper cu constante	Din SDK sau cerut de la mine
ctypes	Pentru accesarea DLL-ului SDK	Inclus Ã®n Python
Tkinter / PyQt5	InterfaÈ›Äƒ graficÄƒ	Tkinter e built-in, PyQt: pip install pyqt5
Matplotlib	AfiÈ™are graficÄƒ a datelor	pip install matplotlib
numpy	Prelucrare numericÄƒ	pip install numpy

ğŸ§­ Roadmap pe roluri â€“ 3 studenÈ›i
ğŸ‘¨â€ğŸ”¬ Student 1 â€“ Specialist hardware & API (WaveForms)
ResponsabilitÄƒÈ›i:

InstaleazÄƒ È™i testeazÄƒ conexiunea cu Analog Discovery 2

Scrie codul de iniÈ›ializare + citire semnal analogic

Sarcini:

InstaleazÄƒ WaveForms È™i SDK

TesteazÄƒ script de citire tensiune analogicÄƒ (pe canal 1)

Expune o funcÈ›ie: def read_voltage(samples, rate): care returneazÄƒ un vector de tensiuni

python
Copy
Edit
# Exemplu pentru citire semnal
def read_voltage(samples=1000, rate=1e4):
    import ctypes
    from dwfconstants import *
    import numpy as np

    dwf = ctypes.cdll.LoadLibrary("C:/Program Files (x86)/Digilent/WaveFormsSDK/lib64/dwf.dll")
    hdwf = ctypes.c_int()
    dwf.FDwfDeviceOpen(ctypes.c_int(-1), ctypes.byref(hdwf))

    # Configurare analog in
    dwf.FDwfAnalogInChannelEnableSet(hdwf, ctypes.c_int(0), ctypes.c_bool(True))
    dwf.FDwfAnalogInChannelRangeSet(hdwf, ctypes.c_int(0), ctypes.c_double(5.0))
    dwf.FDwfAnalogInAcquisitionModeSet(hdwf, acqmodeSingle)
    dwf.FDwfAnalogInFrequencySet(hdwf, ctypes.c_double(rate))
    dwf.FDwfAnalogInBufferSizeSet(hdwf, ctypes.c_int(samples))
    dwf.FDwfAnalogInConfigure(hdwf, ctypes.c_bool(False), ctypes.c_bool(True))

    sts = ctypes.c_byte()
    while True:
        dwf.FDwfAnalogInStatus(hdwf, ctypes.c_bool(True), ctypes.byref(sts))
        if sts.value == DwfStateDone:
            break

    rg = (ctypes.c_double * samples)()
    dwf.FDwfAnalogInStatusData(hdwf, 0, rg, samples)

    dwf.FDwfDeviceCloseAll()
    return np.array(rg)
ğŸ¨ Student 2 â€“ InterfaÈ›Äƒ graficÄƒ (Tkinter sau PyQt)
ResponsabilitÄƒÈ›i:

CreeazÄƒ o interfaÈ›Äƒ cu buton â€Start AchiziÈ›ieâ€

PrimeÈ™te date de la Student 1 È™i le trimite la Student 3 pentru afiÈ™are

Sarcini:

Alege Ã®ntre Tkinter (simplu) sau PyQt5 (mai elegant)

CreeazÄƒ un UI cu:

Buton â€Startâ€

CasetÄƒ pentru numÄƒrul de eÈ™antioane

EtichetÄƒ pentru status (conectat / eÈ™uat)

python
Copy
Edit
import tkinter as tk

def start_acquisition():
    print("AchiziÈ›ie pornitÄƒ...")
    # Aici se va apela read_voltage È™i se va trimite cÄƒtre grafic

root = tk.Tk()
root.title("InterfaÈ›Äƒ AD2")

btn = tk.Button(root, text="Start AchiziÈ›ie", command=start_acquisition)
btn.pack(padx=10, pady=10)

root.mainloop()
ğŸ“Š Student 3 â€“ Procesare + afiÈ™are graficÄƒ (matplotlib / pyqtgraph)
ResponsabilitÄƒÈ›i:

PrimeÈ™te vector de date (semnal)

AfiÈ™eazÄƒ Ã®ntr-un grafic cu axÄƒ de timp

Sarcini:

CreeazÄƒ o funcÈ›ie def plot_signal(data, rate): care primeÈ™te vectorul È™i rata

FoloseÈ™te matplotlib.pyplot sau pyqtgraph pentru afiÈ™are

python
Copy
Edit
import matplotlib.pyplot as plt
import numpy as np

def plot_signal(data, rate):
    t = np.linspace(0, len(data) / rate, len(data))
    plt.plot(t, data)
    plt.xlabel("Timp [s]")
    plt.ylabel("Tensiune [V]")
    plt.title("Semnal achiziÈ›ionat")
    plt.grid(True)
    plt.show()
ğŸ”„ Colaborare Ã®ntre studenÈ›i:
Student 2 (UI) apeleazÄƒ funcÈ›ia read_voltage(...) de la Student 1.

DupÄƒ achiziÈ›ie, trimite rezultatul cÄƒtre plot_signal(...) scris de Student 3.

TesteazÄƒ tot lanÈ›ul de la buton â†’ achiziÈ›ie â†’ afiÈ™are.